from collections import deque
from functools import cache
from enum import IntEnum


class Rules(IntEnum):
    _ROOT = 0
    _TERMINAL = 1
    _SEQUENCE = 2
    _ORDERED_CHOICE = 3
    _NOT_PREDICATE = 4
    _AND_PREDICATE = 5
    _OPTIONAL = 6
    _ZERO_OR_MORE = 7
    _ONE_OR_MORE = 8
    _SUBEXPRESSION = 10
    _VAR_NAME = 11
    _test = 12
    # Following enum values are all autogenerated from grammar file
    Alphabet_Upper = 20
    Alphabet_Lower = 21
    Num = 22
    Spaces = 23
    Specials = 24
    ASCII = 25
    Apostrophe = 26
    Left_Angle_Bracket = 27
    Right_Angle_Bracket = 28
    Left_Bracket = 29
    Right_Bracket = 30
    Assignment = 31
    End_Rule = 32
    Ampersand = 33
    Exclamation_Mark = 34
    Plus = 35
    Star = 36
    Question_Mark = 37
    Comma = 38
    Backslash = 39
    Var_Name = 40
    Subexpression = 41
    Epsilon = 42
    Terminal = 43
    Nucleus = 44
    Atom = 45
    And_Predicate = 46
    Not_Predicate = 47
    Sequence = 48
    Ordered_Choice = 49
    One_Or_More = 50
    Zero_Or_More = 51
    Optional = 52
    Whitespace = 53
    RHS = 54
    LHS = 55
    Rule = 56
    Grammar = 57
    Comment = 58
    Semantic_Instructions = 59
    Delete = 60
    Passthrough = 61
    Collect = 62



class Node():
    """Core data type"""

    def __init__(self, type: int, content: str = ""):
        """Constructor

        Args:
            type (int): int that corresponds to Rules IntEnum telling you what type of Node it is.
            content (str, optional): Content of Node. Defaults to "".
        """
        self.type = type
        self.content = content
        self.children = deque()
        self.parent = None

    def appender(self, node_deque):
        if (isinstance(node_deque, tuple)):
            print("Tuple apparently: ", node_deque)
            raise Exception
        if (node_deque is None):
            return None
        elif (not isinstance(node_deque, deque)):
            self.children.append(node_deque)
        else:
            for child in node_deque:
                self.appender(child)

    def __equals(self, __o: object) -> bool:
        if (__o is None):
            return False
        if (self.content == __o.content and self.type.name == __o.type.name):
            # By name of type as opposed to value because the value can change between
            # parser versions as the enum is autogenerated
            return True
        else:
            return False

    def __eq__(self, __o: object) -> bool:
        """Two Nodes are considered equal if they and all their subchildren have identical types and contents in order"""
        return self.__subtree_equals(__o)

    def __subtree_equals(self, __o: object) -> bool:
        if (self.__equals(__o) is False):
            return False
        else:
            count = 0
            for index, child in enumerate(self.children):
                try:
                    bool = child.__subtree_equals(__o.children[index])
                    count += bool
                except IndexError:
                    return False
            if (count != len(self.children)):
                return False
            else:
                return True

    def pretty_print(self):
        self._pretty_print(self)

    def _pretty_print(self, node, indent=0):
        indent_str = "  "
        if (node is not None):
            print(indent_str * indent +
                  f"Node: {node.type.name}, '{node.content}'")
            for child in node.children:
                self._pretty_print(child, indent + 1)


class Parser():

    def __init__(self):
        self.src = ""

    def _set_src(self, src: str):
        self.src = src
        # Ensures all caches are cleared on resetting the src
        # Resets state completely
        for rule in Rules:
            # Less than 20 is core parser stuff, greater than 20 is inherited
            # class stuff
            if (rule > 0 and rule < 20):
                func = getattr(self, rule.name)
                func.cache_clear()

    def caller(self, position, func, arg=None):
        """Calls generated functions, ensures converted to node not nested deques,
        Useful for testing or calling specific subterminals"""
        return self._VAR_NAME(position, (func, arg))

    def parse(self, src, func, *, arg=None):
        """Pass in the src and the function from the Grammar_Parser class you defined in the Grammar file
        and it will parse it and return the position at which halting stopped, whether the parse succeeded
        and the AST."""
        self._set_src(src)
        position, bool, node = self._VAR_NAME(0, (func, arg))
        if(node is not None):
            pass_two = Parser_Pass_Two()
            pass_two.parse(node)
            return position, bool, node
        else:
            return position, bool, None

    @cache
    def _token(self, position):
        if (position >= len(self.src)):
            return False
        return self.src[position]

    @cache
    def _TERMINAL(self, position: int, arg: str):
        #assert type(position) == int
        #assert type(Arg) == str
        if(arg == ""):
            node = Node(Rules._TERMINAL, None)
            return position, True, node
        token = self._token(position)
        if (token == arg):
            position += 1
            if (token == "\\"):
                token = self._token(position)
                if (token == "n"):
                    position += 1
                    token = "\\n"
                elif (token == "r"):
                    position += 1
                    token = "\\r"
                elif (token == "t"):
                    position += 1
                    token = "\\t"
                else:
                    token = "\\"
            node = Node(Rules._TERMINAL, token)
            return position, True, node
        else:
            # Don't generate anything other than terminal and var on run, means
            # no rationalizer
            return position, False, None

    @cache
    def _VAR_NAME(self, position: int, args):
        """True if called function evaluates to true else false, Is used to call other functions."""
        # where func is a grammar rule
        temp_position = position
        func, args = args
        position, bool, node = func(position, args)
        if (bool):
            key = func.__name__
            var_node = Node(Rules[key], None)
            if (node is not None):
                var_node.appender(node)
                return position, True, var_node
            else:
                return position, True, None
        else:
            position = temp_position
            return position, False, None

    @cache
    def _ORDERED_CHOICE(self, position: int, args):
        """True if one expression matches, then updates position, else false, no positional update"""
        LHS_func, LHS_arg = args[0]
        RHS_func, RHS_arg = args[1]
        temp_position = position
        position, bool, node = LHS_func(position, LHS_arg)
        if (bool):
            return position, True, node
        position = temp_position
        position, bool, node = RHS_func(position, RHS_arg)
        if (bool):
            return position, True, node
        position = temp_position
        return position, False, None

    @cache
    def _SEQUENCE(self, position: int, args):
        """True if all expressions match, then updates position, else false, no positional update"""
        temp_position = position
        LHS_func, LHS_arg = args[0]
        RHS_func, RHS_arg = args[1]
        position, bool, lnode = LHS_func(position, LHS_arg)
        if (bool):
            position, bool, rnode = RHS_func(position, RHS_arg)
            if (bool):
                node = deque()
                node.append(lnode)
                node.append(rnode)
                return position, True, node
            else:
                position = temp_position
                return position, False, None
        else:
            position = temp_position
            return position, False, None

    @cache
    def _ZERO_OR_MORE(self, position: int, args):
        """Always True, increments position each time the expression matches else continues without doing anything"""
        func, arg = args
        zero_nodes = deque()
        while (True):
            temp_position = position
            position, bool, term_node = func(temp_position, arg)
            if (bool):
                zero_nodes.append(term_node)
                continue
            else:
                position = temp_position
                break
        if (len(zero_nodes) == 0):
            return position, True, None
        else:
            return position, True, zero_nodes

    @cache
    def _ONE_OR_MORE(self, position: int, args):
        """Always True, increments position each time the expression matches else continues without doing anything"""
        func, arg = args
        one_nodes = deque()
        while (True):
            temp_position = position
            position, bool, term_node = func(temp_position, arg)
            if (bool):
                one_nodes.append(term_node)
                continue
            else:
                position = temp_position
                break
        if (len(one_nodes) == 0):
            return position, False, None
        else:
            return position, True, one_nodes

    @cache
    def _OPTIONAL(self, position: int, args):
        """Always True, increments position if option matches otherwise continues without doing anything"""
        func, arg = args
        temp_position = position
        position, bool, node = func(temp_position, arg)
        if (bool):
            return position, True, node
        else:
            position = temp_position
            return position, True, None

    @cache
    def _AND_PREDICATE(self, position: int, args):
        """True if the function results in True, never increments position"""
        func, arg = args
        temp_position = position
        position, bool, node = func(position, arg)
        if (bool):
            position = temp_position
            return position, True, None
        else:
            position = temp_position
            return position, False, None

    @cache
    def _NOT_PREDICATE(self, position: int, args):
        """True if the function results in False, never increments position"""
        position, bool, node = self._AND_PREDICATE(position, args)
        return position, not bool, None

    @cache
    def _SUBEXPRESSION(self, position: int, args):
        """Subexpression is any expression inside a pair of () brackets
        SUBEXPR essentially does nothing but allows for order of precedent
        more importantly order of precedence is very restricted because it made my life hard
        (mostly because I can't find a good definition of what order of precedence is in PEG) so use SUBEXPR
        to make more complicated rules"""
        func, arg = args
        temp_position = position
        position, bool, node = func(position, arg)
        if (bool):
            return position, True, node
        else:
            position = temp_position
            return position, False, None

    @cache
    def _test(self, position: int, args):
        """For testing purposes, may be able to refactor somehow to test
        but not sure how"""
        return self._TERMINAL(position, args)

class Parser_Pass_Two():

    def __init__(self):
        self.delete_nodes = (Rules.Apostrophe, Rules.Left_Angle_Bracket, Rules.Right_Angle_Bracket, Rules.Left_Bracket, Rules.Right_Bracket, Rules.Assignment, Rules.End_Rule, Rules.Ampersand, Rules.Exclamation_Mark, Rules.Plus, Rules.Star, Rules.Question_Mark, Rules.Comma, Rules.Backslash, Rules.Whitespace, )
        self.passthrough_nodes = (Rules.Alphabet_Upper, Rules.Alphabet_Lower, Rules.Num, Rules.Spaces, Rules.Specials, Rules.ASCII, Rules.Nucleus, Rules.Atom, Rules.RHS, Rules.Semantic_Instructions, )
        self.collect_nodes = (Rules.Var_Name, Rules.Comment, Rules.Delete, Rules.Passthrough, Rules.Collect, )
        # Anyone making modifications be aware everything after line 10 is
        # automatically added to
        self.tokens = deque()
        # generated parsers while everything before it isn't(so I can add the
        # right stuff based on grammar)

    def token_generator(self, node):
        self.tokens.append(node)
        for child in node.children:
            child.parent = node
            self.token_generator(child)

    def delete_kernel(self, node):
        if (node.type in self.delete_nodes):
            node.children = deque()
            if(node.parent is not None):
                node.parent.children.remove(node)
            del node
        else:
            return node

    def passthrough_kernel(self, node):
        if (node.type in self.passthrough_nodes):
            if(node.parent is not None):
                index = node.parent.children.index(node)
                node.children.reverse()
                for child in node.children:
                    node.parent.children.insert(index, child)
                node.parent.children.remove(node)
            del node
        else:
            return node

    def collect_kernel(self, node):
        if (node.type in self.collect_nodes):
            for child in node.children:
                if (child.type != Rules._TERMINAL):
                    raise ValueError(
                        f"Cannot collect if there are non terminals in the nodes childrens. Node_Type: {node.type.name}, Child_Type: {child.type.name}")
            node.content = ""
            for child in node.children:
                node.content += child.content
            node.children = deque()
            return node
        else:
            return node

    def __parse(self, nodes):
        new_deq = deque()
        for index in range(0, len(nodes)):
            node = nodes.pop()
            node = self.delete_kernel(node)
            if (node is not None):
                node = self.passthrough_kernel(node)
            if (node is not None):
                node = self.collect_kernel(node)
            if (node is not None):
                new_deq.append(node)
        return new_deq

    def parse(self, node):
        self.token_generator(node)
        nodes = deque(self.tokens)
        nodes = self.__parse(nodes)
        return nodes



class Grammar_Parser(Parser):

    def _set_src(self, src: str):
        super()._set_src(src)
        for rule in Rules:
            if(rule >= 20): #Less than 20 is core parser stuff, greatereq than 20 is inherited class stuff
                func = getattr(self, rule.name)
                func.cache_clear()

    @cache
    def Alphabet_Upper(self, position: int, dummy = None):
        """
        <Alphabet_Upper> = "A"/"B"/"C"/"D"/"E"/"F"/"G"/"H"/"I"/"J"/"K"/"L"/"M"/"N"/"O"/"P"/"Q"/"R"/"S"/"T"/"U"/"V"/"W"/"X"/"Y"/"Z" ;
        
        We all love commments
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 65), (&c_terminal, 66)), (&c_terminal, 67)), (&c_terminal, 68)), (&c_terminal, 69)), (&c_terminal, 70)), (&c_terminal, 71)), (&c_terminal, 72)), (&c_terminal, 73)), (&c_terminal, 74)), (&c_terminal, 75)), (&c_terminal, 76)), (&c_terminal, 77)), (&c_terminal, 78)), (&c_terminal, 79)), (&c_terminal, 80)), (&c_terminal, 81)), (&c_terminal, 82)), (&c_terminal, 83)), (&c_terminal, 84)), (&c_terminal, 85)), (&c_terminal, 86)), (&c_terminal, 87)), (&c_terminal, 88)), (&c_terminal, 89)), (&c_terminal, 90)))

    @cache
    def Alphabet_Lower(self, position: int, dummy = None):
        """
        <Alphabet_Lower> = "a"/"b"/"c"/"d"/"e"/"f"/"g"/"h"/"i"/"j"/"k"/"l"/"m"/"n"/"o"/"p"/"q"/"r"/"s"/"t"/"u"/"v"/"w"/"x"/"y"/"z" ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 97), (&c_terminal, 98)), (&c_terminal, 99)), (&c_terminal, 100)), (&c_terminal, 101)), (&c_terminal, 102)), (&c_terminal, 103)), (&c_terminal, 104)), (&c_terminal, 105)), (&c_terminal, 106)), (&c_terminal, 107)), (&c_terminal, 108)), (&c_terminal, 109)), (&c_terminal, 110)), (&c_terminal, 111)), (&c_terminal, 112)), (&c_terminal, 113)), (&c_terminal, 114)), (&c_terminal, 115)), (&c_terminal, 116)), (&c_terminal, 117)), (&c_terminal, 118)), (&c_terminal, 119)), (&c_terminal, 120)), (&c_terminal, 121)), (&c_terminal, 122)))

    @cache
    def Num(self, position: int, dummy = None):
        """
        <Num> = "0"/"1"/"2"/"3"/"4"/"5"/"6"/"7"/"8"/"9" ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 48), (&c_terminal, 49)), (&c_terminal, 50)), (&c_terminal, 51)), (&c_terminal, 52)), (&c_terminal, 53)), (&c_terminal, 54)), (&c_terminal, 55)), (&c_terminal, 56)), (&c_terminal, 57)))

    @cache
    def Spaces(self, position: int, dummy = None):
        """
        <Spaces> = "\n"/"\t"/"\r"/" " ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 10), (&c_terminal, 9)), (&c_terminal, 13)), (&c_terminal, 32)))

    @cache
    def Specials(self, position: int, dummy = None):
        """
        <Specials> = "+"/"*"/"-"/"&"/"!"/"?"/"<"/">"/'"'/"("/")"/"_"/","/"/"/";"/"="/"\\"/"#"/":"/"|"/"."/"{"/"}"/"["/"]"/"%"/"'"/"^"/"~" ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 43), (&c_terminal, 42)), (&c_terminal, 45)), (&c_terminal, 38)), (&c_terminal, 33)), (&c_terminal, 63)), (&c_terminal, 60)), (&c_terminal, 62)), (&c_terminal, '34')), (&c_terminal, 40)), (&c_terminal, 41)), (&c_terminal, 95)), (&c_terminal, 44)), (&c_terminal, 47)), (&c_terminal, 59)), (&c_terminal, 61)), (&c_terminal, '92')), (&c_terminal, 35)), (&c_terminal, 58)), (&c_terminal, 124)), (&c_terminal, 46)), (&c_terminal, 123)), (&c_terminal, 125)), (&c_terminal, 91)), (&c_terminal, 93)), (&c_terminal, 37)), (&c_terminal, 39)), (&c_terminal, 94)), (&c_terminal, 126)))

    @cache
    def ASCII(self, position: int, dummy = None):
        """
        <ASCII> = <Alphabet_Lower>/<Alphabet_Upper>/<Num>/<Spaces>/<Specials> ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&Alphabet_Lower, 0)), (&c_var_name, (&Alphabet_Upper, 0))), (&c_var_name, (&Num, 0))), (&c_var_name, (&Spaces, 0))), (&c_var_name, (&Specials, 0))))

    @cache
    def Apostrophe(self, position: int, dummy = None):
        """
        <Apostrophe> = '"' ;
        """
        return c_subexpression(&mut po, (&c_terminal, '34'))

    @cache
    def Left_Angle_Bracket(self, position: int, dummy = None):
        """
        <Left_Angle_Bracket> = "<" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 60))

    @cache
    def Right_Angle_Bracket(self, position: int, dummy = None):
        """
        <Right_Angle_Bracket> = ">" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 62))

    @cache
    def Left_Bracket(self, position: int, dummy = None):
        """
        <Left_Bracket> = "(" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 40))

    @cache
    def Right_Bracket(self, position: int, dummy = None):
        """
        <Right_Bracket> = ")" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 41))

    @cache
    def Assignment(self, position: int, dummy = None):
        """
        <Assignment> = "=" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 61))

    @cache
    def End_Rule(self, position: int, dummy = None):
        """
        <End_Rule> = ";" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 59))

    @cache
    def Ampersand(self, position: int, dummy = None):
        """
        <Ampersand> = "&" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 38))

    @cache
    def Exclamation_Mark(self, position: int, dummy = None):
        """
        <Exclamation_Mark> = "!" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 33))

    @cache
    def Plus(self, position: int, dummy = None):
        """
        <Plus> = "+" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 43))

    @cache
    def Star(self, position: int, dummy = None):
        """
        <Star> = "*" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 42))

    @cache
    def Question_Mark(self, position: int, dummy = None):
        """
        <Question_Mark> = "?" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 63))

    @cache
    def Comma(self, position: int, dummy = None):
        """
        <Comma> = "," ;
        """
        return c_subexpression(&mut po, (&c_terminal, 44))

    @cache
    def Backslash(self, position: int, dummy = None):
        """
        <Backslash> = "/" ;
        """
        return c_subexpression(&mut po, (&c_terminal, 47))

    @cache
    def Var_Name(self, position: int, dummy = None):
        """
        <Var_Name> = <Left_Angle_Bracket>, (<Alphabet_Lower>/<Alphabet_Upper>), (<Alphabet_Lower>/<Alphabet_Upper>/"_")*, <Right_Angle_Bracket> ;
        
        Not whitespace dependent, feel free to use multiple lines for readability
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&Left_Angle_Bracket, 0)), (&c_subexpression, (&c_ordered_choice, (&c_var_name, (&Alphabet_Lower, 0)), (&c_var_name, (&Alphabet_Upper, 0))))), (&c_zero_or_more, (&c_subexpression, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&Alphabet_Lower, 0)), (&c_var_name, (&Alphabet_Upper, 0))), (&c_terminal, 95))))), (&c_var_name, (&Right_Angle_Bracket, 0))))

    @cache
    def Subexpression(self, position: int, dummy = None):
        """
        <Subexpression> = <Left_Bracket>, <RHS>, <Right_Bracket> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_var_name, (&Left_Bracket, 0)), (&c_var_name, (&RHS, 0))), (&c_var_name, (&Right_Bracket, 0))))

    @cache
    def Epsilon(self, position: int, dummy = None):
        """
        <Epsilon> = <Apostrophe>, <Apostrophe> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_var_name, (&Apostrophe, 0)), (&c_var_name, (&Apostrophe, 0))))

    @cache
    def Terminal(self, position: int, dummy = None):
        """
        <Terminal> = (<Apostrophe>, <ASCII>, <Apostrophe>)/(<Apostrophe>, "\\", ("n"/"r"/"t"), <Apostrophe>)/<Epsilon> ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_subexpression, (&c_sequence, (&c_sequence, (&c_var_name, (&Apostrophe, 0)), (&c_var_name, (&ASCII, 0))), (&c_var_name, (&Apostrophe, 0)))), (&c_subexpression, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&Apostrophe, 0)), (&c_terminal, '92')), (&c_subexpression, (&c_ordered_choice, (&c_ordered_choice, (&c_terminal, 110), (&c_terminal, 114)), (&c_terminal, 116)))), (&c_var_name, (&Apostrophe, 0))))), (&c_var_name, (&Epsilon, 0))))

    @cache
    def Nucleus(self, position: int, dummy = None):
        """
        <Nucleus> = (<Subexpression>/<Terminal>/<Var_Name>), <Whitespace> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_subexpression, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&Subexpression, 0)), (&c_var_name, (&Terminal, 0))), (&c_var_name, (&Var_Name, 0)))), (&c_var_name, (&Whitespace, 0))))

    @cache
    def Atom(self, position: int, dummy = None):
        """
        <Atom> = (<And_Predicate>/<Not_Predicate>/<One_Or_More>/<Zero_Or_More>/<Optional>/<Nucleus>), <Whitespace> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_subexpression, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&And_Predicate, 0)), (&c_var_name, (&Not_Predicate, 0))), (&c_var_name, (&One_Or_More, 0))), (&c_var_name, (&Zero_Or_More, 0))), (&c_var_name, (&Optional, 0))), (&c_var_name, (&Nucleus, 0)))), (&c_var_name, (&Whitespace, 0))))

    @cache
    def And_Predicate(self, position: int, dummy = None):
        """
        <And_Predicate> = <Ampersand>, <Nucleus> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_var_name, (&Ampersand, 0)), (&c_var_name, (&Nucleus, 0))))

    @cache
    def Not_Predicate(self, position: int, dummy = None):
        """
        <Not_Predicate> = <Exclamation_Mark>, <Nucleus> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_var_name, (&Exclamation_Mark, 0)), (&c_var_name, (&Nucleus, 0))))

    @cache
    def Sequence(self, position: int, dummy = None):
        """
        <Sequence> = <Atom>, <Whitespace>, <Comma>, <Whitespace>, <Atom>, (<Comma>, <Whitespace>, <Atom>)* ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&Atom, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Comma, 0))), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Atom, 0))), (&c_zero_or_more, (&c_subexpression, (&c_sequence, (&c_sequence, (&c_var_name, (&Comma, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Atom, 0)))))))

    @cache
    def Ordered_Choice(self, position: int, dummy = None):
        """
        <Ordered_Choice> = <Atom>, <Whitespace>, <Backslash>, <Whitespace>, <Atom>, (<Backslash>, <Whitespace>, <Atom>)* ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&Atom, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Backslash, 0))), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Atom, 0))), (&c_zero_or_more, (&c_subexpression, (&c_sequence, (&c_sequence, (&c_var_name, (&Backslash, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Atom, 0)))))))

    @cache
    def One_Or_More(self, position: int, dummy = None):
        """
        <One_Or_More> = <Nucleus>, <Whitespace>, <Plus> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_var_name, (&Nucleus, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Plus, 0))))

    @cache
    def Zero_Or_More(self, position: int, dummy = None):
        """
        <Zero_Or_More> = <Nucleus>, <Whitespace>, <Star> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_var_name, (&Nucleus, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Star, 0))))

    @cache
    def Optional(self, position: int, dummy = None):
        """
        <Optional> = <Nucleus>, <Whitespace>, <Question_Mark> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_var_name, (&Nucleus, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Question_Mark, 0))))

    @cache
    def Whitespace(self, position: int, dummy = None):
        """
        <Whitespace> = (" "/"\n")* ;
        """
        return c_subexpression(&mut po, (&c_zero_or_more, (&c_subexpression, (&c_ordered_choice, (&c_terminal, 32), (&c_terminal, 10)))))

    @cache
    def RHS(self, position: int, dummy = None):
        """
        <RHS> = <Sequence>/<Ordered_Choice>/<Atom> ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&Sequence, 0)), (&c_var_name, (&Ordered_Choice, 0))), (&c_var_name, (&Atom, 0))))

    @cache
    def LHS(self, position: int, dummy = None):
        """
        <LHS> = <Var_Name>, (<Whitespace>, <Semantic_Instructions>, <Whitespace>)? ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_var_name, (&Var_Name, 0)), (&c_optional, (&c_subexpression, (&c_sequence, (&c_sequence, (&c_var_name, (&Whitespace, 0)), (&c_var_name, (&Semantic_Instructions, 0))), (&c_var_name, (&Whitespace, 0)))))))

    @cache
    def Rule(self, position: int, dummy = None):
        """
        <Rule> = <LHS>, <Whitespace>, <Assignment>, <Whitespace>, <RHS>, <Whitespace>, <End_Rule>, <Whitespace>, <Comment>* ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&LHS, 0)), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&Assignment, 0))), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&RHS, 0))), (&c_var_name, (&Whitespace, 0))), (&c_var_name, (&End_Rule, 0))), (&c_var_name, (&Whitespace, 0))), (&c_zero_or_more, (&c_var_name, (&Comment, 0)))))

    @cache
    def Grammar(self, position: int, dummy = None):
        """
        <Grammar> = <Rule>+, <Whitespace> ;
        
        Double up dem comments
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_one_or_more, (&c_var_name, (&Rule, 0))), (&c_var_name, (&Whitespace, 0))))

    @cache
    def Comment(self, position: int, dummy = None):
        """
        <Comment> = <Whitespace>, "#", (!"#", <ASCII>)*, "#", <Whitespace> ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_var_name, (&Whitespace, 0)), (&c_terminal, 35)), (&c_zero_or_more, (&c_subexpression, (&c_sequence, (&c_not, (&c_terminal, 35)), (&c_var_name, (&ASCII, 0)))))), (&c_terminal, 35)), (&c_var_name, (&Whitespace, 0))))

    @cache
    def Semantic_Instructions(self, position: int, dummy = None):
        """
        <Semantic_Instructions> = <Delete>/<Passthrough>/<Collect> ;
        """
        return c_subexpression(&mut po, (&c_ordered_choice, (&c_ordered_choice, (&c_var_name, (&Delete, 0)), (&c_var_name, (&Passthrough, 0))), (&c_var_name, (&Collect, 0))))

    @cache
    def Delete(self, position: int, dummy = None):
        """
        <Delete> = "D", "E", "L", "E", "T", "E" ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_terminal, 68), (&c_terminal, 69)), (&c_terminal, 76)), (&c_terminal, 69)), (&c_terminal, 84)), (&c_terminal, 69)))

    @cache
    def Passthrough(self, position: int, dummy = None):
        """
        <Passthrough> = "P", "A", "S", "S", "T", "H", "R", "O", "U", "G", "H" ;
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_terminal, 80), (&c_terminal, 65)), (&c_terminal, 83)), (&c_terminal, 83)), (&c_terminal, 84)), (&c_terminal, 72)), (&c_terminal, 82)), (&c_terminal, 79)), (&c_terminal, 85)), (&c_terminal, 71)), (&c_terminal, 72)))

    @cache
    def Collect(self, position: int, dummy = None):
        """
        <Collect> = "C", "O", "L", "L", "E", "C", "T" ;
        
        Comment
        """
        return c_subexpression(&mut po, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_sequence, (&c_terminal, 67), (&c_terminal, 79)), (&c_terminal, 76)), (&c_terminal, 76)), (&c_terminal, 69)), (&c_terminal, 67)), (&c_terminal, 84)))
